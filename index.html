<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>空間図形 3Dビューワー</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (JSX変換用) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; touch-action: none; }
        /* モバイルでの選択防止 */
        * { -webkit-user-select: none; user-select: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- アイコンコンポーネント (Lucide-reactの簡易版) ---
        const Icon = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const BoxIcon = (props) => (
            <Icon {...props}><path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z"/><path d="m3.3 7 8.7 5 8.7-5"/><path d="M12 22v-9"/></Icon>
        );
        const Rotate3dIcon = (props) => (
            <Icon {...props}><path d="M16.466 7.5C15.643 4.237 13.952 2 12 2 9.239 2 7 6.477 7 12s2.239 10 5 10c.342 0 .677-.069 1-.2"/><path d="m15.194 13.707 3.814 1.86-1.86 3.814"/><path d="M19 15.57c-1.804.885-4.274 1.43-7 1.43-5.523 0-10-2.239-10-5s4.477-5 10-5c4.838 0 8.873 1.718 9.8 4"/></Icon>
        );
        const MousePointer2Icon = (props) => (
            <Icon {...props}><path d="m12 12 6.88-6.88a2.12 2.12 0 0 0-3-3L9 9"/><path d="m21.9 14.12-3.83-1.85-2.05 4.96a2 2 0 0 1-3.69-1.5l2.06-4.96-1.86-3.82a2 2 0 0 1 3.42-1.95l3.9 9.38a2 2 0 0 1-1.95 3.56Z"/></Icon>
        );
        const LayersIcon = (props) => (
            <Icon {...props}><path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/></Icon>
        );
        const EyeIcon = (props) => (
            <Icon {...props}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></Icon>
        );
        const RefreshCcwIcon = (props) => (
            <Icon {...props}><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></Icon>
        );
        const ScanEyeIcon = (props) => (
            <Icon {...props}><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><circle cx="12" cy="12" r="1"/><path d="M5 12s2.5-5 7-5 7 5 7 5-2.5 5-7 5-7-5-7-5z"/></Icon>
        );
        const SearchIcon = (props) => (
            <Icon {...props}><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></Icon>
        );

        // --- メインアプリケーション ---
        const App = () => {
            const mountRef = useRef(null);
            const [activeShapes, setActiveShapes] = useState({
                cube: true,
                rectPyramid: true,
                triPrism: true,
                triPyramid: true,
                cylinder: true,
                cone: true,
                sphere: true,
            });
            const [showWireframe, setShowWireframe] = useState(true);
            const [isAutoRotating, setIsAutoRotating] = useState(false);

            const sceneRef = useRef(null);
            const shapesRef = useRef({});
            const controlsRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const frameIdRef = useRef(null);

            // データ定義（ジグザグ配置）
            const shapesData = [
                { id: 'cube', name: '四角柱 (直方体)', color: 0x3b82f6, position: [-9, 0, -1.5] },
                { id: 'rectPyramid', name: '四角錐', color: 0xf97316, position: [-6, 0, 2.5] },
                { id: 'triPrism', name: '三角柱', color: 0x06b6d4, position: [-3, 0, -1.5] }, 
                { id: 'triPyramid', name: '三角錐', color: 0xef4444, position: [0, 0, 2.5] },
                { id: 'cylinder', name: '円柱', color: 0x8b5cf6, position: [3, 0, -1.5] },
                { id: 'cone', name: '円錐', color: 0xeab308, position: [6, 0, 2.5] },
                { id: 'sphere', name: '球', color: 0x10b981, position: [9, 0, -1.5] },
            ];

            useEffect(() => {
                initThreeJS();
                return () => {
                    if (frameIdRef.current) cancelAnimationFrame(frameIdRef.current);
                    if (rendererRef.current && mountRef.current) {
                        mountRef.current.removeChild(rendererRef.current.domElement);
                    }
                };
            }, []);

            useEffect(() => {
                if (!sceneRef.current) return;
                Object.keys(shapesRef.current).forEach(key => {
                    const group = shapesRef.current[key];
                    if (group) {
                        group.visible = activeShapes[key];
                        const mesh = group.children[0];
                        const wireframe = group.children[1];
                        if (mesh) {
                            mesh.material.opacity = showWireframe ? 0.7 : 1.0;
                            mesh.material.transparent = true;
                        }
                        if (wireframe) {
                            wireframe.visible = showWireframe;
                        }
                    }
                });
            }, [activeShapes, showWireframe]);

            const initThreeJS = () => {
                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f4f8);
                sceneRef.current = scene;

                let radius = 22;
                let target = new THREE.Vector3(0, 0, 0);
                let theta = 0;
                let phi = Math.PI / 3;

                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                const gridHelper = new THREE.GridHelper(30, 30, 0x94a3b8, 0xcbd5e1);
                scene.add(gridHelper);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                const materialParams = { transparent: true, opacity: 0.8, shininess: 60, side: THREE.DoubleSide };
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });

                shapesData.forEach(data => {
                    let geometry;
                    let yOffset = 1;
                    switch (data.id) {
                        case 'cube': geometry = new THREE.BoxGeometry(2, 2, 2); break;
                        case 'rectPyramid': geometry = new THREE.ConeGeometry(1.5, 2, 4); break;
                        case 'triPrism': geometry = new THREE.CylinderGeometry(1.5, 1.5, 2, 3); break;
                        case 'triPyramid': geometry = new THREE.ConeGeometry(1.5, 2, 3); break;
                        case 'cylinder': geometry = new THREE.CylinderGeometry(1, 1, 2, 32); break;
                        case 'cone': geometry = new THREE.ConeGeometry(1.2, 2, 32); break;
                        case 'sphere': geometry = new THREE.SphereGeometry(1.2, 32, 32); yOffset = 1.2; break;
                        default: geometry = new THREE.BoxGeometry(1, 1, 1);
                    }

                    const material = new THREE.MeshPhongMaterial({ ...materialParams, color: data.color });
                    const mesh = new THREE.Mesh(geometry, material);
                    const edges = new THREE.EdgesGeometry(geometry);
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    const group = new THREE.Group();
                    group.add(mesh);
                    group.add(wireframe);
                    group.position.set(...data.position);
                    group.position.y = yOffset;
                    
                    if (data.id === 'rectPyramid') group.rotation.y = Math.PI / 4;
                    if (data.id === 'triPrism') group.rotation.y = Math.PI / 2;
                    if (data.id === 'triPyramid') group.rotation.y = Math.PI;

                    scene.add(group);
                    shapesRef.current[data.id] = group;
                });

                const updateCamera = () => {
                    const x = radius * Math.sin(phi) * Math.sin(theta);
                    const y = radius * Math.cos(phi);
                    const z = radius * Math.sin(phi) * Math.cos(theta);
                    camera.position.set(target.x + x, target.y + y, target.z + z);
                    camera.lookAt(target);
                };

                // 操作イベント
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                const onMouseDown = (e) => { isDragging = true; };
                const onMouseUp = (e) => { isDragging = false; };
                const onMouseMove = (e) => {
                    if (isDragging) {
                        const deltaMove = { x: e.offsetX - previousMousePosition.x, y: e.offsetY - previousMousePosition.y };
                        theta -= deltaMove.x * 0.01;
                        phi -= deltaMove.y * 0.01;
                        phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, phi));
                        updateCamera();
                    }
                    previousMousePosition = { x: e.offsetX, y: e.offsetY };
                };

                const onWheel = (e) => {
                    e.preventDefault();
                    radius += e.deltaY * 0.05;
                    radius = Math.max(4, Math.min(60, radius));
                    updateCamera();
                };

                // タッチ操作
                let initialPinchDistance = null;
                let initialRadius = null;

                const onTouchStart = (e) => {
                    if (e.touches.length === 1) {
                        isDragging = true;
                        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    } else if (e.touches.length === 2) {
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        initialPinchDistance = Math.hypot(dx, dy);
                        initialRadius = radius;
                    }
                };

                const onTouchMove = (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1 && isDragging) {
                        const deltaMove = { x: e.touches[0].clientX - previousMousePosition.x, y: e.touches[0].clientY - previousMousePosition.y };
                        theta -= deltaMove.x * 0.01;
                        phi -= deltaMove.y * 0.01;
                        phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, phi));
                        updateCamera();
                        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    } else if (e.touches.length === 2 && initialPinchDistance) {
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        const distance = Math.hypot(dx, dy);
                        radius = initialRadius * (initialPinchDistance / distance);
                        radius = Math.max(4, Math.min(60, radius));
                        updateCamera();
                    }
                };

                const onTouchEnd = () => { isDragging = false; initialPinchDistance = null; };

                const dom = renderer.domElement;
                dom.addEventListener('mousedown', onMouseDown);
                dom.addEventListener('mouseup', onMouseUp);
                dom.addEventListener('mousemove', onMouseMove);
                dom.addEventListener('wheel', onWheel, { passive: false });
                dom.addEventListener('touchstart', onTouchStart, {passive: false});
                dom.addEventListener('touchmove', onTouchMove, {passive: false});
                dom.addEventListener('touchend', onTouchEnd);

                const animate = () => {
                    frameIdRef.current = requestAnimationFrame(animate);
                    if (controlsRef.current?.isAutoRotating) {
                        theta += 0.005;
                        updateCamera();
                    }
                    renderer.render(scene, camera);
                };
                updateCamera();
                animate();

                const handleResize = () => {
                    if (!mountRef.current) return;
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);

                controlsRef.current = {
                    updateCamera: (t, p) => { theta = t; phi = p; updateCamera(); },
                    setAutoRotate: (val) => { controlsRef.current.isAutoRotating = val; },
                    focusOn: (pos) => {
                        target.set(pos[0], pos[1], pos[2]);
                        radius = 8;
                        phi = Math.PI / 3;
                        updateCamera();
                    },
                    reset: () => {
                        target.set(0, 0, 0);
                        radius = 22;
                        theta = 0;
                        phi = Math.PI / 3;
                        updateCamera();
                    }
                };
            };

            const toggleShape = (id) => setActiveShapes(prev => ({ ...prev, [id]: !prev[id] }));
            const toggleAll = (show) => {
                const newState = {};
                Object.keys(activeShapes).forEach(key => newState[key] = show);
                setActiveShapes(newState);
            };
            const toggleAutoRotate = () => {
                const newVal = !isAutoRotating;
                setIsAutoRotating(newVal);
                if (controlsRef.current) controlsRef.current.setAutoRotate(newVal);
            };
            const resetCamera = () => {
                if (controlsRef.current) {
                    controlsRef.current.reset();
                    setIsAutoRotating(false);
                }
            };
            const focusShape = (id, position) => {
                if (!activeShapes[id]) setActiveShapes(prev => ({ ...prev, [id]: true }));
                if (controlsRef.current) {
                    controlsRef.current.focusOn(position);
                    setIsAutoRotating(true);
                }
            };

            return (
                <div className="flex flex-col h-screen bg-gray-50 font-sans text-gray-800">
                    <header className="bg-white p-3 shadow-sm z-10 flex justify-between items-center shrink-0">
                        <div>
                            <h1 className="text-lg md:text-xl font-bold flex items-center gap-2 text-indigo-700">
                                <BoxIcon size={24} /> 空間図形 3Dビューワー
                            </h1>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={resetCamera} className="px-3 py-2 text-sm bg-gray-100 hover:bg-gray-200 rounded flex items-center gap-1">
                                <RefreshCcwIcon size={16} /> <span className="hidden md:inline">リセット</span>
                            </button>
                            <button onClick={toggleAutoRotate} className={`px-3 py-2 text-sm rounded flex items-center gap-1 transition-colors ${isAutoRotating ? 'bg-indigo-100 text-indigo-700' : 'bg-gray-100 hover:bg-gray-200'}`}>
                                <Rotate3dIcon size={16} /> <span className="hidden md:inline">{isAutoRotating ? '停止' : '自動回転'}</span>
                            </button>
                        </div>
                    </header>

                    <div className="flex flex-1 overflow-hidden relative">
                        <div className="flex-1 relative bg-slate-100" ref={mountRef}>
                            <div className="absolute top-4 left-4 bg-white/80 backdrop-blur p-2 rounded text-xs text-gray-600 pointer-events-none select-none shadow-sm z-10">
                                <div className="flex flex-col gap-1">
                                    <div className="flex items-center gap-1"><MousePointer2Icon size={12}/> 指で回転</div>
                                    <div className="flex items-center gap-1"><SearchIcon size={12}/> ピンチで拡大</div>
                                </div>
                            </div>
                        </div>

                        <div className="w-64 md:w-80 bg-white shadow-xl overflow-y-auto border-l border-gray-200 p-2 md:p-4 flex flex-col gap-4 shrink-0">
                            <div className="space-y-2">
                                <h2 className="text-xs md:text-sm font-bold text-gray-500 uppercase tracking-wider flex items-center gap-2">
                                    <EyeIcon size={16} /> 表示設定
                                </h2>
                                <label className="flex items-center justify-between p-2 rounded bg-indigo-50 cursor-pointer hover:bg-indigo-100 transition">
                                    <span className="text-sm font-medium text-indigo-900">骨組み (辺)</span>
                                    <input type="checkbox" checked={showWireframe} onChange={() => setShowWireframe(!showWireframe)} className="w-4 h-4 text-indigo-600 rounded"/>
                                </label>
                            </div>

                            <div className="space-y-2">
                                <div className="flex justify-between items-center">
                                    <h2 className="text-xs md:text-sm font-bold text-gray-500 uppercase tracking-wider flex items-center gap-2">
                                        <LayersIcon size={16} /> 立体の選択
                                    </h2>
                                    <div className="text-xs space-x-2 text-blue-600">
                                        <button onClick={() => toggleAll(true)} className="hover:underline">全表示</button>
                                        <button onClick={() => toggleAll(false)} className="hover:underline">全消去</button>
                                    </div>
                                </div>
                                <div className="grid grid-cols-1 gap-1 md:gap-2">
                                    {shapesData.map((shape) => (
                                        <div key={shape.id} className={`flex items-center justify-between p-2 rounded border transition-all ${activeShapes[shape.id] ? 'bg-white border-gray-300 shadow-sm' : 'bg-gray-50 border-gray-100 opacity-60'}`}>
                                            <label className="flex items-center flex-1 cursor-pointer min-w-0">
                                                <input type="checkbox" checked={activeShapes[shape.id]} onChange={() => toggleShape(shape.id)} className="w-4 h-4 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500"/>
                                                <div className="ml-2 md:ml-3 flex items-center gap-2 min-w-0">
                                                    <div className="w-3 h-3 rounded-full flex-shrink-0" style={{ backgroundColor: '#' + shape.color.toString(16) }}></div>
                                                    <span className="text-sm font-medium truncate">{shape.name}</span>
                                                </div>
                                            </label>
                                            <button onClick={() => focusShape(shape.id, shape.position)} className="ml-1 md:ml-2 p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-full transition-colors" title="ズーム">
                                                <ScanEyeIcon size={18} />
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>